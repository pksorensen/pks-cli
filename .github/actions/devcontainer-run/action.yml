name: 'Devcontainer Run'
description: 'Run commands inside a devcontainer. Works on self-hosted runners without root/sudo.'

inputs:
  command:
    description: 'Command(s) to run inside the devcontainer'
    required: true
  workspace-folder:
    description: 'Path to workspace containing .devcontainer/'
    required: false
    default: '.'
  config:
    description: 'Explicit path to devcontainer.json'
    required: false
    default: ''
  env:
    description: 'Environment variables, one per line (KEY=VALUE or KEY to inherit from host)'
    required: false
    default: ''
  shell:
    description: 'Shell for wrapping commands. Use "none" to exec each line separately.'
    required: false
    default: '/bin/sh'
  up-args:
    description: 'Extra arguments for devcontainer up'
    required: false
    default: ''
  devcontainer-cli-version:
    description: 'Version of @devcontainers/cli to install'
    required: false
    default: 'latest'
  remote-user:
    description: 'Override the remote user for exec. Use "root" to fix permission issues with bind-mounted sources.'
    required: false
    default: ''
  skip-cleanup:
    description: 'Keep the container alive for downstream steps'
    required: false
    default: 'false'

outputs:
  container-id:
    description: 'Docker container ID of the running devcontainer'
    value: ${{ steps.up.outputs.container-id }}
  remote-user:
    description: 'Remote user inside the devcontainer'
    value: ${{ steps.up.outputs.remote-user }}
  remote-workspace-folder:
    description: 'Workspace folder path inside the devcontainer'
    value: ${{ steps.up.outputs.remote-workspace-folder }}

runs:
  using: 'composite'
  steps:
    # 1. Install devcontainer CLI to a user-local prefix (no root needed)
    - name: Install devcontainer CLI
      shell: bash
      run: |
        NPM_PREFIX="$HOME/.devcontainer-cli"
        mkdir -p "$NPM_PREFIX"

        VERSION="${{ inputs.devcontainer-cli-version }}"
        if [ "$VERSION" = "latest" ]; then
          PACKAGE="@devcontainers/cli"
        else
          PACKAGE="@devcontainers/cli@$VERSION"
        fi

        echo "::group::Installing $PACKAGE to $NPM_PREFIX"
        npm install --prefix "$NPM_PREFIX" -g "$PACKAGE"
        echo "::endgroup::"

        echo "$NPM_PREFIX/bin" >> "$GITHUB_PATH"
        export PATH="$NPM_PREFIX/bin:$PATH"

        echo "Installed devcontainer CLI:"
        devcontainer --version

    # 2. Build and start the devcontainer
    - name: devcontainer up
      id: up
      shell: bash
      run: |
        ARGS="--workspace-folder ${{ inputs.workspace-folder }}"

        if [ -n "${{ inputs.config }}" ]; then
          ARGS="$ARGS --config ${{ inputs.config }}"
        fi

        # Build --remote-env flags from env input
        ENV_FLAGS=""
        if [ -n "${{ inputs.env }}" ]; then
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            if [[ "$line" == *"="* ]]; then
              ENV_FLAGS="$ENV_FLAGS --remote-env $line"
            else
              # Inherit from host
              ENV_FLAGS="$ENV_FLAGS --remote-env ${line}=${!line}"
            fi
          done <<< "${{ inputs.env }}"
        fi

        if [ -n "${{ inputs.remote-user }}" ]; then
          ARGS="$ARGS --remote-user ${{ inputs.remote-user }}"
        fi

        if [ -n "${{ inputs.up-args }}" ]; then
          ARGS="$ARGS ${{ inputs.up-args }}"
        fi

        LOG_FILE=$(mktemp)
        echo "Running: devcontainer up $ARGS $ENV_FLAGS"

        # Stream output in real-time to both console and log file
        devcontainer up $ARGS $ENV_FLAGS 2>&1 | tee "$LOG_FILE"
        EXIT_CODE=${PIPESTATUS[0]}

        if [ $EXIT_CODE -ne 0 ]; then
          echo "::error::devcontainer up failed with exit code $EXIT_CODE"
          echo "--- Full output ---"
          cat "$LOG_FILE"
          rm -f "$LOG_FILE"
          exit $EXIT_CODE
        fi

        # Parse the last JSON line from output
        JSON_LINE=$(grep -o '{.*}' "$LOG_FILE" | tail -1)
        rm -f "$LOG_FILE"

        CONTAINER_ID=$(echo "$JSON_LINE" | jq -r '.containerId // empty')
        REMOTE_USER=$(echo "$JSON_LINE" | jq -r '.remoteUser // empty')
        REMOTE_WORKSPACE=$(echo "$JSON_LINE" | jq -r '.remoteWorkspaceFolder // empty')

        if [ -z "$CONTAINER_ID" ]; then
          echo "::error::Could not parse container ID from devcontainer up output"
          echo "Raw output: $OUTPUT"
          exit 1
        fi

        echo "container-id=$CONTAINER_ID" >> "$GITHUB_OUTPUT"
        echo "remote-user=$REMOTE_USER" >> "$GITHUB_OUTPUT"
        echo "remote-workspace-folder=$REMOTE_WORKSPACE" >> "$GITHUB_OUTPUT"

        echo "Container ID: $CONTAINER_ID"
        echo "Remote user: $REMOTE_USER"
        echo "Remote workspace: $REMOTE_WORKSPACE"

    # 3. Execute the user's command inside the devcontainer
    - name: devcontainer exec
      shell: bash
      run: |
        ARGS="--workspace-folder ${{ inputs.workspace-folder }}"

        if [ -n "${{ inputs.config }}" ]; then
          ARGS="$ARGS --config ${{ inputs.config }}"
        fi

        if [ -n "${{ inputs.remote-user }}" ]; then
          ARGS="$ARGS --remote-user ${{ inputs.remote-user }}"
        fi

        # Build --remote-env flags
        ENV_FLAGS=""
        if [ -n "${{ inputs.env }}" ]; then
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            if [[ "$line" == *"="* ]]; then
              ENV_FLAGS="$ENV_FLAGS --remote-env $line"
            else
              ENV_FLAGS="$ENV_FLAGS --remote-env ${line}=${!line}"
            fi
          done <<< "${{ inputs.env }}"
        fi

        SHELL_CMD="${{ inputs.shell }}"
        COMMAND=$(cat <<'COMMAND_EOF'
        ${{ inputs.command }}
        COMMAND_EOF
        )

        if [ "$SHELL_CMD" = "none" ]; then
          # Execute each non-empty line as a separate devcontainer exec call
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            echo "::group::exec: $line"
            devcontainer exec $ARGS $ENV_FLAGS $line
            EXIT_CODE=$?
            echo "::endgroup::"
            if [ $EXIT_CODE -ne 0 ]; then
              echo "::error::Command failed: $line (exit code $EXIT_CODE)"
              exit $EXIT_CODE
            fi
          done <<< "$COMMAND"
        else
          echo "::group::exec via $SHELL_CMD"
          devcontainer exec $ARGS $ENV_FLAGS "$SHELL_CMD" -c "$COMMAND"
          EXIT_CODE=$?
          echo "::endgroup::"
          if [ $EXIT_CODE -ne 0 ]; then
            exit $EXIT_CODE
          fi
        fi

    # 4. Cleanup: remove the container unless skip-cleanup is true
    - name: Cleanup devcontainer
      if: always()
      shell: bash
      run: |
        if [ "${{ inputs.skip-cleanup }}" = "true" ]; then
          echo "Skipping cleanup (skip-cleanup=true)"
          exit 0
        fi

        CONTAINER_ID="${{ steps.up.outputs.container-id }}"
        if [ -n "$CONTAINER_ID" ]; then
          echo "Removing container $CONTAINER_ID"
          docker rm -f "$CONTAINER_ID" 2>/dev/null || true
        fi
