{
  "articles/advanced/configuration.html": {
    "href": "articles/advanced/configuration.html",
    "title": "Configuration\\n\\nComing soon - configuration documentation. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Configuration\\n\\nComing soon - configuration documentation."
  },
  "articles/advanced/custom-initializers.html": {
    "href": "articles/advanced/custom-initializers.html",
    "title": "Custom Initializers\\n\\nComing soon - custom initializer guide. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Custom Initializers\\n\\nComing soon - custom initializer guide."
  },
  "articles/advanced/mcp-integration.html": {
    "href": "articles/advanced/mcp-integration.html",
    "title": "MCP Integration\\n\\nComing soon - MCP integration guide. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "MCP Integration\\n\\nComing soon - MCP integration guide."
  },
  "articles/advanced/template-development.html": {
    "href": "articles/advanced/template-development.html",
    "title": "Template Development\\n\\nComing soon - template development guide. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Template Development\\n\\nComing soon - template development guide."
  },
  "articles/architecture/agent-framework.html": {
    "href": "articles/architecture/agent-framework.html",
    "title": "Agent Framework\\n\\nComing soon - agent framework documentation. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Agent Framework\\n\\nComing soon - agent framework documentation."
  },
  "articles/architecture/command-system.html": {
    "href": "articles/architecture/command-system.html",
    "title": "Command System\\n\\nComing soon - command system documentation. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Command System\\n\\nComing soon - command system documentation."
  },
  "articles/architecture/initializer-system.html": {
    "href": "articles/architecture/initializer-system.html",
    "title": "Initializer System\\n\\nComing soon - initializer system documentation. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Initializer System\\n\\nComing soon - initializer system documentation."
  },
  "articles/architecture/overview.html": {
    "href": "articles/architecture/overview.html",
    "title": "Architecture Overview\\n\\nComing soon - detailed architecture documentation. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Architecture Overview\\n\\nComing soon - detailed architecture documentation."
  },
  "articles/commands/agent.html": {
    "href": "articles/commands/agent.html",
    "title": "pks agent - AI Agent Management | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "pks agent - AI Agent Management The pks agent command enables you to create, manage, and coordinate AI agents that assist with various development tasks. Overview AI agents in PKS CLI are specialized assistants that help with: Code Generation - Writing boilerplate and complex logic Testing - Creating and maintaining test suites Documentation - Generating and updating docs Architecture - Designing system components DevOps - Managing deployments and infrastructure Syntax pks agent <SUBCOMMAND> [OPTIONS] Subcommands create Create a new AI agent with specified capabilities. pks agent create --name <NAME> --type <TYPE> [OPTIONS] Options: --name <NAME> - Agent name (required) --type <TYPE> - Agent type: developer, testing, documentation, architecture, devops --description <TEXT> - Agent description --specialization <AREA> - Specific area of focus --shared - Make agent available to team Examples: # Create a development agent pks agent create --name DevBot --type developer # Create a specialized testing agent pks agent create --name TestMaster --type testing --specialization \"API testing\" # Create a shared documentation agent pks agent create --name DocsBot --type documentation --shared --description \"Technical writing expert\" list Display all available agents and their status. pks agent list [OPTIONS] Options: --format <FORMAT> - Output format: table, json, minimal --status <STATUS> - Filter by status: active, idle, stopped --type <TYPE> - Filter by agent type Examples: # List all agents pks agent list # List only active agents pks agent list --status active # JSON output for scripts pks agent list --format json start Start an agent to begin accepting tasks. pks agent start <NAME> [OPTIONS] Options: --background - Run agent in background --auto-accept - Automatically accept compatible tasks --max-tasks <NUM> - Maximum concurrent tasks (default: 3) Examples: # Start an agent interactively pks agent start DevBot # Start agent in background pks agent start TestBot --background --auto-accept stop Stop a running agent. pks agent stop <NAME> [OPTIONS] Options: --force - Force stop without completing current tasks --save-state - Save current progress before stopping status Show detailed status information for an agent. pks agent status <NAME> [OPTIONS] Options: --detailed - Show extended information --logs - Include recent log entries --format <FORMAT> - Output format remove Remove an agent permanently. pks agent remove <NAME> [OPTIONS] Options: --force - Remove without confirmation --backup - Create backup before removal Agent Types Developer Agent Specializes in code-related tasks: Code generation and refactoring Bug fixing and optimization Code review and analysis Implementation of features pks agent create --name CodeMaster --type developer --specialization \"API development\" Testing Agent Focuses on quality assurance: Unit test creation Integration test design Test automation Performance testing pks agent create --name TestBot --type testing --specialization \"automated testing\" Documentation Agent Handles documentation tasks: API documentation generation User guide creation Technical writing Documentation maintenance pks agent create --name DocsExpert --type documentation Architecture Agent Provides system design guidance: System architecture design Design pattern recommendations Performance optimization Scalability planning pks agent create --name ArchBot --type architecture --specialization \"microservices\" DevOps Agent Manages deployment and operations: CI/CD pipeline creation Infrastructure management Monitoring setup Deployment automation pks agent create --name DeployBot --type devops --specialization \"Kubernetes\" Agent Coordination Task Assignment Agents can work together on complex tasks: # Create a team of agents pks agent create --name DevLead --type developer --specialization \"coordination\" pks agent create --name BackendDev --type developer --specialization \"APIs\" pks agent create --name FrontendDev --type developer --specialization \"UI/UX\" pks agent create --name QAEngineer --type testing # Start the team pks agent start DevLead --auto-accept pks agent start BackendDev --background pks agent start FrontendDev --background pks agent start QAEngineer --background Communication Agents can communicate through the PKS message system: # View agent messages pks agent messages DevBot # Send message to agent pks agent send DevBot \"Focus on performance optimization\" Configuration Agent Configuration File Agents are configured in ~/.pks/agents/<name>/config.json: { \"name\": \"DevBot\", \"type\": \"developer\", \"specialization\": \"API development\", \"capabilities\": [ \"code-generation\", \"refactoring\", \"testing\", \"documentation\" ], \"preferences\": { \"codeStyle\": \"standard\", \"testFramework\": \"xUnit\", \"maxConcurrentTasks\": 3 }, \"learning\": { \"enabled\": true, \"feedback\": true, \"adaptation\": true } } Global Agent Settings Configure agent behavior in pks.config.json: { \"agents\": { \"autoSpawn\": true, \"defaultType\": \"developer\", \"maxConcurrentAgents\": 5, \"learningEnabled\": true, \"communicationEnabled\": true, \"taskTimeout\": 1800 } } Examples Development Workflow # Setup development team pks agent create --name TeamLead --type developer --specialization \"coordination\" pks agent create --name APIBot --type developer --specialization \"REST APIs\" pks agent create --name DBBot --type developer --specialization \"database design\" # Start the agents pks agent start TeamLead --background --auto-accept pks agent start APIBot --background pks agent start DBBot --background # Monitor progress pks agent status TeamLead --detailed pks agent list --status active Testing Pipeline # Create testing specialists pks agent create --name UnitTester --type testing --specialization \"unit tests\" pks agent create --name IntegrationTester --type testing --specialization \"integration tests\" pks agent create --name E2ETester --type testing --specialization \"end-to-end tests\" # Run comprehensive testing pks agent start UnitTester --auto-accept pks agent start IntegrationTester --auto-accept pks agent start E2ETester --auto-accept Integration with MCP Agents integrate seamlessly with MCP servers: # Start MCP server with agent tools pks mcp start --enable-agents --port 3000 # Agents become available as MCP tools for AI clients Best Practices Naming Conventions Use descriptive names: APITester, DocsWriter, DeployBot Include specialization: ReactExpert, KubernetesOps Avoid generic names: Agent1, Bot, Helper Agent Specialization Create focused agents rather than generalists Specialize agents for specific technologies or frameworks Use type-appropriate specializations Team Coordination Assign a coordinator agent for complex projects Use clear communication channels between agents Monitor agent workloads and performance Resource Management Limit concurrent agents based on system resources Stop idle agents to conserve memory Use background mode for long-running tasks Troubleshooting Agent Won't Start # Check agent configuration pks agent status MyAgent --detailed # View logs pks agent logs MyAgent # Restart agent pks agent stop MyAgent --force pks agent start MyAgent Performance Issues # Limit concurrent tasks pks agent configure MyAgent --max-tasks 2 # Monitor resource usage pks agent stats --all # Stop idle agents pks agent stop --idle Next Steps Working with Agents Tutorial - Learn agent workflows MCP Integration - Connect agents to AI tools Architecture Guide - Understand agent internals Ready to create your first AI development team? \uD83E\uDD16 pks agent create --name DevAssistant --type developer pks agent start DevAssistant"
  },
  "articles/commands/ascii.html": {
    "href": "articles/commands/ascii.html",
    "title": "ASCII Command\\n\\nComing soon - ASCII command documentation. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "ASCII Command\\n\\nComing soon - ASCII command documentation."
  },
  "articles/commands/deploy.html": {
    "href": "articles/commands/deploy.html",
    "title": "Deploy Command\\n\\nComing soon - deploy command documentation. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Deploy Command\\n\\nComing soon - deploy command documentation."
  },
  "articles/commands/init.html": {
    "href": "articles/commands/init.html",
    "title": "pks init - Project Initialization | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "pks init - Project Initialization The pks init command is the cornerstone of PKS CLI, designed to create intelligent, well-structured projects with agentic capabilities built-in from day one. Syntax pks init [<PROJECT_NAME>] [OPTIONS] Description pks init creates a new project with: Smart Templates - Choose from predefined project templates Agentic Integration - Optional AI agent capabilities MCP Configuration - Model Context Protocol for AI tools Best Practices - Modern project structure and tooling Documentation - Comprehensive README and development guides Arguments Argument Description PROJECT_NAME Name of the project (optional - will prompt if not provided) Options Basic Options Option Short Description Default --template <TYPE> -t Project template to use console --description <TEXT> -d Project description --force -f Overwrite existing directory false --no-interactive Skip interactive prompts false Advanced Options Option Description Default --agentic Enable agentic capabilities false --mcp Include MCP (Model Context Protocol) setup false --git-init Initialize Git repository true --install-deps Install NuGet dependencies after creation true --open-editor Open project in default editor false Template-Specific Options Option Applies To Description --framework <VERSION> All .NET framework version (default: net8.0) --auth <TYPE> api, web Authentication type (none, jwt, oauth) --database <TYPE> api, web Database provider (none, sqlite, sqlserver, postgres) --frontend <TYPE> web Frontend framework (none, blazor, react, vue) Templates Available Templates Template Description Best For console Console application CLI tools, utilities, background services api REST API with controllers Web APIs, microservices, data services web Web application Full-stack applications, websites agent Specialized agent project AI agents, automation tools library Class library Reusable components, NuGet packages Template Features Console Template pks init my-console --template console --agentic Generated Structure: my-console/ ├── Program.cs # Entry point with dependency injection ├── Commands/ # Command pattern structure ├── Services/ # Business logic services ├── my-console.csproj # Project file with common packages ├── README.md # Comprehensive documentation ├── .gitignore # .NET specific ignores └── CLAUDE.md # AI development guidance (if --agentic) API Template pks init my-api --template api --auth jwt --database postgres --agentic Generated Structure: my-api/ ├── Controllers/ # API controllers ├── Models/ # Data models and DTOs ├── Services/ # Business logic ├── Data/ # Database context and migrations ├── Program.cs # Startup configuration ├── appsettings.json # Configuration ├── my-api.csproj # Project with API packages └── ... Web Template pks init my-web --template web --frontend blazor --auth oauth --agentic Generated Structure: my-web/ ├── Pages/ # Razor pages or components ├── Components/ # Reusable UI components ├── wwwroot/ # Static files ├── Controllers/ # MVC controllers ├── Models/ # View models and entities ├── Services/ # Application services ├── Program.cs # Web host configuration └── ... Interactive Mode When you run pks init without arguments, it enters interactive mode: pks init Interactive Prompts: \uD83E\uDD16 PKS CLI Project Initialization ? What is your project name? my-awesome-project ? Choose a template: > console api web agent library ? Project description: A revolutionary CLI tool ? Enable agentic capabilities? (Y/n) Y ? Include MCP integration? (Y/n) Y ? Initialize Git repository? (Y/n) Y ? Open in editor after creation? (Y/n) n ✨ Creating project with the following configuration: • Name: my-awesome-project • Template: console • Agentic: enabled • MCP: enabled • Git: enabled \uD83D\uDE80 Project created successfully! Examples Basic Project Creation # Simple console application pks init calculator --template console # API with description pks init todo-api --template api --description \"A simple todo API\" # Web application with authentication pks init my-blog --template web --auth jwt --frontend blazor Agentic Projects # Console app with AI capabilities pks init smart-cli --template console --agentic --mcp # AI-powered API pks init intelligent-api --template api --agentic --description \"API with AI agents\" # Full-stack agentic application pks init agentic-web --template web --agentic --mcp --frontend react Advanced Scenarios # Override existing directory pks init existing-project --force --template api # Custom framework version pks init legacy-app --template console --framework net6.0 # No interactive prompts (CI/CD friendly) pks init ci-project --template api --description \"CI build\" --no-interactive # Complete setup with all features pks init full-stack \\ --template web \\ --agentic \\ --mcp \\ --auth oauth \\ --database postgres \\ --frontend react \\ --description \"Full-featured application\" \\ --open-editor Configuration Project Configuration File The init command can use a configuration file for defaults: pks.init.json: { \"defaults\": { \"template\": \"api\", \"enableAgentic\": true, \"enableMcp\": true, \"framework\": \"net8.0\", \"auth\": \"jwt\", \"database\": \"postgres\" }, \"templates\": { \"api\": { \"packages\": [ \"Microsoft.AspNetCore.Authentication.JwtBearer\", \"Swashbuckle.AspNetCore\" ] } } } Use with: pks init my-project --config pks.init.json Environment Variables export PKS_DEFAULT_TEMPLATE=api export PKS_ENABLE_AGENTIC=true export PKS_DEFAULT_AUTH=jwt export PKS_AUTO_OPEN_EDITOR=true Generated Files Core Files (All Templates) File Description {ProjectName}.csproj Project file with dependencies Program.cs Application entry point .gitignore Git ignore rules for .NET README.md Project documentation Agentic Files (--agentic flag) File Description CLAUDE.md AI development guidance agents/ Agent configuration directory pks.config.json PKS CLI configuration MCP Files (--mcp flag) File Description .mcp.json MCP server configuration mcp-config.yml Extended MCP settings mcp/ MCP tools and prompts Initializer System PKS CLI uses a sophisticated initializer system to create projects: Execution Order DotNetProjectInitializer (Order: 10) - Creates basic .NET structure AgenticFeaturesInitializer (Order: 50) - Adds AI capabilities McpConfigurationInitializer (Order: 75) - Configures MCP ClaudeDocumentationInitializer (Order: 80) - Generates AI docs ReadmeInitializer (Order: 90) - Creates comprehensive README Custom Initializers You can create custom initializers for specific needs: # List available initializers pks init --list-initializers # Run specific initializers only pks init my-project --initializers dotnet,agentic --template api Troubleshooting Common Issues Directory Already Exists ❌ Error: Directory 'my-project' already exists \uD83D\uDCA1 Use --force to overwrite or choose a different name Solutions: # Option 1: Use force flag pks init my-project --force # Option 2: Different name pks init my-project-v2 # Option 3: Remove existing directory rm -rf my-project && pks init my-project Template Not Found ❌ Error: Template 'custom' not found \uD83D\uDCA1 Available templates: console, api, web, agent, library Solution: # List available templates pks init --list-templates # Use valid template pks init my-project --template api Missing Dependencies ❌ Error: Failed to restore NuGet packages \uD83D\uDCA1 Ensure internet connection and valid NuGet sources Solutions: # Skip dependency installation pks init my-project --no-install-deps # Manually restore later cd my-project && dotnet restore # Clear NuGet cache dotnet nuget locals all --clear Best Practices Naming Conventions Use kebab-case for project names: my-awesome-api Avoid special characters except hyphens Keep names concise but descriptive Template Selection console - CLI tools, services, utilities api - REST APIs, web services, microservices web - Full applications with UI agent - AI agents and automation tools library - Shared code and NuGet packages Agentic Features Enable --agentic for projects that will benefit from AI assistance Use --mcp when integrating with AI tools like Claude or GitHub Copilot Consider the learning curve for team members new to agentic development Integration CI/CD Pipelines # GitHub Actions - name: Initialize Project run: | pks init ${{ github.event.repository.name }} \\ --template api \\ --no-interactive \\ --description \"Auto-generated API project\" # Azure DevOps - script: | pks init $(Build.Repository.Name) --template web --no-interactive displayName: 'Initialize Project' Development Workflows # Team development setup pks init team-project --template api --agentic --mcp cd team-project pks agent create --name TeamBot --type developer --shared git add . && git commit -m \"Initial project setup\" git push origin main Next Steps After creating a project with pks init: Explore the generated structure Set up agents for AI assistance Configure MCP for tool integration Deploy your application when ready Ready to create your first agentic project? \uD83D\uDE80 pks init my-first-agentic-app --template api --agentic --mcp"
  },
  "articles/commands/mcp.html": {
    "href": "articles/commands/mcp.html",
    "title": "MCP Command\\n\\nComing soon - MCP command documentation. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "MCP Command\\n\\nComing soon - MCP command documentation."
  },
  "articles/commands/overview.html": {
    "href": "articles/commands/overview.html",
    "title": "Commands Overview | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Commands Overview PKS CLI provides a comprehensive set of commands designed to streamline your agentic development workflow. Each command is built with beautiful terminal UI and intelligent automation. Command Categories \uD83C\uDFD7️ Project Management pks init - Initialize new projects with intelligent templates \uD83E\uDD16 Agent Operations pks agent - Create and manage AI development agents \uD83D\uDE80 Deployment & Operations pks deploy - Deploy applications with AI optimization pks status - Monitor system status with real-time insights \uD83C\uDFA8 Utilities pks ascii - Generate beautiful ASCII art and animations \uD83D\uDD0C Integration pks mcp - Model Context Protocol server for AI tool connectivity Global Options All commands support these global options: Option Short Description --help -h Show help information --version -v Display version information --verbose Enable verbose logging --quiet -q Suppress non-essential output --no-logo Skip the ASCII banner --config <file> -c Use specific configuration file Common Patterns Interactive Mode Most commands support interactive mode when required parameters are missing: # These will prompt for missing information pks init pks agent create pks deploy Output Formatting Commands support different output formats: # JSON output for scripts pks status --format json # Table format for humans (default) pks agent list --format table # Minimal output for CI/CD pks deploy --format minimal Configuration Precedence All commands follow this configuration hierarchy: Command-line arguments (highest priority) Environment variables (PKS_*) Project configuration (./pks.config.json) User configuration (~/.pks/config.json) System defaults (lowest priority) Quick Reference Essential Commands # Create a new project pks init my-app --template api --agentic # Create and start an agent pks agent create --name DevBot --type developer pks agent start DevBot # Deploy your application pks deploy --environment staging --watch # Monitor system status pks status --watch --ai-insights # Generate ASCII art for your README pks ascii \"My Project\" --style banner > header.txt Advanced Usage # Initialize with custom configuration pks init --config ./custom-config.json --template web --agentic --mcp # Deploy with AI optimization pks deploy --ai-optimize --auto-rollback --health-check-timeout 300 # Start MCP server with custom port pks mcp start --port 4000 --enable-cors --log-level debug # Create specialized agents pks agent create --name TesterBot --type testing --specialization \"API testing\" pks agent create --name DocsBot --type documentation --focus \"technical writing\" Environment Variables Configure PKS CLI behavior with environment variables: # Global settings export PKS_DEFAULT_TEMPLATE=api export PKS_ENABLE_TELEMETRY=false export PKS_CONFIG_PATH=~/.pks/custom-config.json # Agent settings export PKS_AGENT_AUTO_SPAWN=true export PKS_AGENT_LEARNING_ENABLED=true export PKS_AGENT_DEFAULT_TYPE=developer # UI settings export PKS_COLOR_SCHEME=cyan export PKS_DISABLE_ANIMATIONS=false export PKS_ASCII_ART_ENABLED=true # Deployment settings export PKS_DEFAULT_ENVIRONMENT=dev export PKS_AI_OPTIMIZATION=true export PKS_AUTO_WATCH=false Command Chaining PKS CLI supports command chaining for complex workflows: # Create, configure, and deploy in one line pks init my-api --template api && cd my-api && pks agent create --name ApiBot && pks deploy --environment dev Error Handling PKS CLI provides clear error messages and suggestions: # Example error output ❌ Error: Project directory 'my-app' already exists \uD83D\uDCA1 Suggestion: Use --force to overwrite or choose a different name \uD83D\uDD27 Alternative: pks init my-app-v2 --template api Help System Get help for any command: # General help pks --help # Command-specific help pks init --help pks agent create --help # Show examples pks deploy --examples # Show all available templates pks init --list-templates Tab Completion Enable tab completion in your shell: Bash # Add to ~/.bashrc eval \"$(pks completion bash)\" Zsh # Add to ~/.zshrc eval \"$(pks completion zsh)\" PowerShell # Add to PowerShell profile pks completion powershell | Out-String | Invoke-Expression Configuration File Create a global configuration file at ~/.pks/config.json: { \"defaults\": { \"template\": \"api\", \"enableAgentic\": true, \"enableMcp\": true }, \"agents\": { \"autoSpawn\": true, \"defaultType\": \"developer\", \"learningEnabled\": true, \"maxConcurrentAgents\": 3 }, \"ui\": { \"colorScheme\": \"cyan\", \"animations\": true, \"asciiArt\": true, \"progressBars\": true }, \"deployment\": { \"defaultEnvironment\": \"dev\", \"aiOptimization\": true, \"autoWatch\": false, \"healthCheckTimeout\": 300 }, \"mcp\": { \"defaultPort\": 3000, \"enableCors\": true, \"logLevel\": \"info\" } } Performance Tips Faster Command Execution # Disable non-essential features for CI/CD export PKS_DISABLE_ANIMATIONS=true export PKS_ASCII_ART_ENABLED=false export PKS_QUIET=true Parallel Operations # Run multiple agents concurrently pks agent create --name DevBot1 & pks agent create --name DevBot2 & pks agent create --name TestBot & wait Integration Examples CI/CD Pipeline # GitHub Actions example - name: Initialize project run: pks init ${{ github.event.repository.name }} --template api --no-interactive - name: Deploy run: pks deploy --environment staging --format json --wait Development Scripts #!/bin/bash # Development setup script set -e pks init \"$1\" --template \"${2:-api}\" --agentic cd \"$1\" pks agent create --name DevBot --type developer pks mcp start --daemon echo \"✅ Development environment ready!\" Next Steps pks init - Learn about project initialization pks agent - Discover agent management capabilities pks deploy - Master deployment workflows Tutorials - Follow step-by-step guides Ready to dive deeper into specific commands? Pick one from the navigation menu! \uD83D\uDE80"
  },
  "articles/commands/status.html": {
    "href": "articles/commands/status.html",
    "title": "Status Command\\n\\nComing soon - status command documentation. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Status Command\\n\\nComing soon - status command documentation."
  },
  "articles/contributing.html": {
    "href": "articles/contributing.html",
    "title": "Contributing to PKS CLI | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Contributing to PKS CLI Thank you for your interest in contributing to PKS CLI! This guide will help you get started with contributing to the project. Getting Started Development Setup Fork the Repository # Fork on GitHub: https://github.com/pksorensen/pks-cli/fork git clone https://github.com/YOUR_USERNAME/pks-cli.git cd pks-cli Install Prerequisites .NET 8.0 SDK Git Your favorite code editor Build the Project cd pks-cli/src dotnet restore dotnet build Run Tests dotnet test Development Workflow Create a Feature Branch git checkout -b feature/your-feature-name Make Your Changes Follow the coding standards Add tests for new functionality Update documentation as needed Test Your Changes # Build and test dotnet build dotnet test # Test the CLI locally dotnet run -- --help Submit a Pull Request Push your branch to your fork Create a PR with a clear description Link to any related issues Code Standards Coding Style Follow standard .NET conventions Use meaningful variable and method names Add XML documentation for public APIs Keep methods focused and concise Spectre.Console Usage Use Spectre.Console for all terminal output Maintain consistent color schemes (cyan for primary) Include progress indicators for long operations Use tables with rounded borders for data display Command Pattern Inherit from Command<T> for new commands Create settings classes with proper attributes Implement interactive prompts for missing parameters Include comprehensive help text Project Structure pks-cli/ ├── src/ │ ├── Commands/ # Command implementations │ ├── Infrastructure/ # Services and DI setup │ ├── Templates/ # Template files │ └── Program.cs # Entry point ├── tests/ # Test projects ├── docs/ # Documentation └── README.md # Project overview Adding New Features Creating a New Command Create the Command Class public class MyCommand : Command<MyCommand.Settings> { public class Settings : CommandSettings { [CommandArgument(0, \"<NAME>\")] public string? Name { get; init; } [CommandOption(\"--option\")] public string? Option { get; init; } } public override int Execute(CommandContext context, Settings settings) { // Implementation return 0; } } Register the Command // In Program.cs app.Configure(config => { config.AddCommand<MyCommand>(\"my-command\"); }); Creating an Initializer Create the Initializer Class public class MyInitializer : CodeInitializer { public override string Id => \"my-initializer\"; public override string Name => \"My Initializer\"; public override int Order => 50; protected override async Task ExecuteCodeLogicAsync( InitializationContext context, InitializationResult result) { // Implementation } } Register the Initializer Initializers are auto-discovered via reflection. Testing Unit Tests Write unit tests for all public methods Use xUnit testing framework Mock external dependencies Test both success and failure scenarios Integration Tests Test command execution end-to-end Verify file generation and structure Test error scenarios and recovery Example Test [Fact] public void Should_Create_Project_With_Correct_Structure() { // Arrange var tempDir = CreateTempDirectory(); var settings = new InitCommand.Settings { ProjectName = \"test-project\", Template = \"console\" }; // Act var result = ExecuteCommand(settings); // Assert Assert.Equal(0, result); Assert.True(File.Exists(Path.Join(tempDir, \"test-project.csproj\"))); } Documentation API Documentation Use XML documentation comments Include parameter descriptions Provide usage examples Document exceptions User Documentation Update relevant documentation pages Add examples for new features Include troubleshooting information Keep language clear and accessible Pull Request Process Before Submitting Ensure all tests pass dotnet test Run code formatting dotnet format Update documentation Add/update XML comments Update user documentation Include examples Test manually # Install and test locally dotnet pack dotnet tool install -g --add-source ./bin/Debug pks-cli --force pks --help PR Description Include in your PR description: What: Brief description of changes Why: Reason for the change How: Implementation approach Testing: How you tested the changes Breaking Changes: Any breaking changes (if applicable) Review Process Automated Checks: All CI checks must pass Code Review: Core maintainers will review Testing: Manual testing by reviewers Approval: At least one approval required Merge: Squash and merge to main branch Issue Reporting Bug Reports When reporting bugs, include: Environment: OS, .NET version, PKS CLI version Steps to Reproduce: Clear, numbered steps Expected Behavior: What should happen Actual Behavior: What actually happens Additional Context: Screenshots, logs, etc. Feature Requests For new features, provide: Problem Statement: What problem does this solve? Proposed Solution: How should it work? Alternatives: Other approaches considered Examples: Usage examples and scenarios Community Guidelines Code of Conduct Be respectful and inclusive Focus on constructive feedback Help others learn and grow Assume positive intent Communication GitHub Issues: Bug reports and feature requests GitHub Discussions: Questions and general discussion Pull Requests: Code contributions and reviews Recognition Contributors are recognized in: CONTRIBUTORS.md: All contributors listed Release Notes: Major contributions highlighted GitHub: Contributor badge and statistics Getting Help Need help contributing? Documentation: Start with this guide Issues: Check existing issues for similar questions Discussions: Ask questions in GitHub Discussions Code: Look at existing implementations for patterns License By contributing to PKS CLI, you agree that your contributions will be licensed under the MIT License. Thank you for contributing to PKS CLI! Every contribution, whether code, documentation, or feedback, helps make the project better for everyone. \uD83D\uDE4F"
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started with PKS CLI | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Getting Started with PKS CLI Welcome to PKS CLI! This guide will help you get started with the Professional Agentic Simplifier and create your first intelligent development project. Prerequisites Before you begin, ensure you have: .NET 8.0 SDK or later installed PowerShell (Windows) or Bash/Zsh (macOS/Linux) Git for version control A code editor like Visual Studio Code or Visual Studio Installation Option 1: Install as .NET Global Tool (Recommended) # Install PKS CLI globally dotnet tool install -g pks-cli # Verify installation pks --version Option 2: Install from Source # Clone the repository git clone https://github.com/pksorensen/pks-cli cd pks-cli/pks-cli/src # Build and install locally dotnet build --configuration Release dotnet pack --configuration Release dotnet tool install -g --add-source ./bin/Release pks-cli --force Your First Project Let's create your first agentic project with PKS CLI: 1. Initialize a New Project # Create a new API project with agentic capabilities pks init my-agentic-api --template api --agentic --description \"My first agentic API project\" This command will: Create a new directory my-agentic-api Set up a .NET API project structure Configure agentic capabilities Add necessary dependencies and templates Create documentation and configuration files 2. Explore the Generated Structure cd my-agentic-api ls -la You'll see a project structure like: my-agentic-api/ ├── .gitignore ├── my-agentic-api.csproj ├── Program.cs ├── README.md ├── CLAUDE.md # AI development guidance ├── .mcp.json # Model Context Protocol config └── ... 3. Build and Run # Build the project dotnet build # Run the application dotnet run Understanding Agentic Development PKS CLI introduces the concept of agentic development - a workflow where AI agents assist with various development tasks: What are Agents? Agents are specialized AI assistants that help with: Code Generation: Writing boilerplate and complex logic Testing: Creating and maintaining test suites Documentation: Generating and updating documentation Architecture: Designing system components DevOps: Managing deployments and infrastructure Agent Management # Create a new agent pks agent create --name CodeMaster --type developer # List all agents pks agent list # Check agent status pks agent status CodeMaster Interactive Mode PKS CLI supports interactive mode for a guided experience: # Start interactive project creation pks init # Follow the prompts to configure your project: # - Project name # - Template selection # - Features and capabilities # - Description and metadata Command Overview Here are the main commands you'll use: Command Description Example pks init Create new projects pks init my-app --template web pks agent Manage AI agents pks agent create --name TestBot pks deploy Deploy applications pks deploy --environment prod pks status System monitoring pks status --watch pks ascii Generate ASCII art pks ascii \"Hello\" --style banner pks mcp MCP server management pks mcp start --port 3000 Configuration PKS CLI uses a hierarchical configuration system: Command-line arguments (highest priority) Environment variables (PKS_*) User config (~/.pks/config.json) Project config (./pks.config.json) Built-in defaults (lowest priority) Example Configuration Create pks.config.json in your project: { \"agents\": { \"autoSpawn\": true, \"defaultType\": \"developer\", \"learningEnabled\": true }, \"ui\": { \"colorScheme\": \"cyan\", \"animations\": true, \"asciiArt\": true }, \"deployment\": { \"defaultEnvironment\": \"dev\", \"aiOptimization\": true } } Next Steps Now that you have PKS CLI set up: Explore Commands - Learn about all available commands Work with Agents - Dive deeper into agent capabilities Set up MCP - Enable AI tool integration Deploy Your App - Learn deployment strategies Getting Help Built-in Help: pks --help or pks [command] --help Documentation: You're reading it! \uD83D\uDCD6 GitHub Issues: Report bugs or request features Discussions: Ask questions and share experiences Welcome to the future of agentic .NET development! \uD83D\uDE80"
  },
  "articles/installation.html": {
    "href": "articles/installation.html",
    "title": "Installation Guide | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Installation Guide This guide covers all the ways to install PKS CLI on different platforms and environments. System Requirements Minimum Requirements .NET 8.0 SDK or later Windows 10/11, macOS 10.14+, or Linux (Ubuntu 18.04+, etc.) 4 GB RAM (8 GB recommended) 500 MB free disk space Terminal with Unicode support Recommended Setup Visual Studio Code with C# extension Git for version control Docker (optional, for deployment features) PowerShell 7+ on all platforms Installation Methods \uD83D\uDE80 Method 1: .NET Global Tool (Recommended) This is the fastest and easiest way to install PKS CLI: # Install the latest version dotnet tool install -g pks-cli # Verify installation pks --version # Update to latest version dotnet tool update -g pks-cli Advantages: Automatic updates available Works on all platforms Integrates with .NET ecosystem Easy to uninstall \uD83D\uDD27 Method 2: From Source For development or custom builds: # Clone the repository git clone https://github.com/pksorensen/pks-cli.git cd pks-cli/pks-cli/src # Build in Release mode dotnet build --configuration Release # Create NuGet package dotnet pack --configuration Release # Install locally dotnet tool install -g --add-source ./bin/Release pks-cli --force # Verify installation pks --version Advantages: Get the latest features Contribute to development Custom modifications possible \uD83D\uDC33 Method 3: Docker (Coming Soon) Container-based installation: # Pull the Docker image docker pull pkscli/pks-cli:latest # Run PKS CLI in container docker run --rm -it -v $(pwd):/workspace pkscli/pks-cli:latest --help # Create an alias for easier use alias pks='docker run --rm -it -v $(pwd):/workspace pkscli/pks-cli:latest' \uD83D\uDCE6 Method 4: Package Managers Windows (Chocolatey) # Install Chocolatey first if needed # Coming soon choco install pks-cli macOS (Homebrew) # Coming soon brew install pks-cli Linux (Snap) # Coming soon sudo snap install pks-cli Platform-Specific Instructions Windows Prerequisites # Check .NET version dotnet --version # Install .NET 8 if needed # Download from: https://dotnet.microsoft.com/download Installation # Install PKS CLI dotnet tool install -g pks-cli # Add to PATH if needed (usually automatic) # $env:PATH += \";$env:USERPROFILE\\.dotnet\\tools\" PowerShell Profile Setup Add to your PowerShell profile for better experience: # Add to $PROFILE function pks-init { pks init $args } function pks-deploy { pks deploy $args } Set-Alias pk pks macOS Prerequisites # Check .NET version dotnet --version # Install .NET 8 using Homebrew brew install --cask dotnet # Or download from Microsoft # https://dotnet.microsoft.com/download Installation # Install PKS CLI dotnet tool install -g pks-cli # Ensure tools directory is in PATH echo 'export PATH=\"$PATH:$HOME/.dotnet/tools\"' >> ~/.zshrc source ~/.zshrc Shell Configuration For Zsh (default on macOS): # Add to ~/.zshrc alias pk='pks' export PKS_DEFAULT_TEMPLATE='web' Linux (Ubuntu/Debian) Prerequisites # Install .NET 8 wget https://packages.microsoft.com/config/ubuntu/22.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb sudo dpkg -i packages-microsoft-prod.deb sudo apt-get update sudo apt-get install -y dotnet-sdk-8.0 Installation # Install PKS CLI dotnet tool install -g pks-cli # Add to PATH echo 'export PATH=\"$PATH:$HOME/.dotnet/tools\"' >> ~/.bashrc source ~/.bashrc Linux (CentOS/RHEL/Fedora) Prerequisites # Install .NET 8 sudo dnf install dotnet-sdk-8.0 # Or for older versions sudo yum install dotnet-sdk-8.0 Verification After installation, verify everything is working: # Check version pks --version # View help pks --help # Test basic functionality pks ascii \"PKS CLI\" --style banner # Check all commands are available pks init --help pks agent --help pks deploy --help pks status --help pks mcp --help Expected output: PKS CLI version 1.0.0 \uD83E\uDD16 Professional Agentic Simplifier Built with ❤️ using .NET 8 Troubleshooting Common Issues 1. \"pks command not found\" Solution: # Check if tools directory is in PATH echo $PATH | grep -q \".dotnet/tools\" && echo \"✓ PATH configured\" || echo \"✗ PATH missing\" # Add to PATH manually export PATH=\"$PATH:$HOME/.dotnet/tools\" # Make permanent (add to shell profile) echo 'export PATH=\"$PATH:$HOME/.dotnet/tools\"' >> ~/.bashrc 2. \".NET SDK not found\" Solution: # Check .NET installation dotnet --info # Install .NET 8 SDK # Windows: Download from Microsoft # macOS: brew install --cask dotnet # Linux: Follow platform-specific instructions above 3. \"Access denied\" on Windows Solution: # Run PowerShell as Administrator Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser # Then retry installation dotnet tool install -g pks-cli 4. PKS CLI crashes on startup Solution: # Check for conflicting global tools dotnet tool list -g # Reinstall PKS CLI dotnet tool uninstall -g pks-cli dotnet tool install -g pks-cli # Clear .NET cache dotnet nuget locals all --clear Getting More Help If you encounter issues: Check System Requirements - Ensure .NET 8+ is installed Update .NET SDK - dotnet --version should show 8.0+ Reinstall PKS CLI - Sometimes a clean reinstall fixes issues Check GitHub Issues - Search for similar problems Create New Issue - Report new bugs or problems Uninstallation To remove PKS CLI: # Uninstall global tool dotnet tool uninstall -g pks-cli # Remove configuration files (optional) rm -rf ~/.pks # Remove from PATH (if added manually) # Edit your shell profile and remove PKS CLI path entries Next Steps Now that PKS CLI is installed: Get Started - Create your first project Command Reference - Learn all the commands Configuration - Customize your setup Ready to build something awesome? Let's get started! \uD83D\uDE80"
  },
  "articles/troubleshooting.html": {
    "href": "articles/troubleshooting.html",
    "title": "Troubleshooting | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Troubleshooting This guide helps you resolve common issues when using PKS CLI. Installation Issues Command Not Found Problem: bash: pks: command not found Solutions: Check if PKS CLI is installed: dotnet tool list -g | grep pks-cli Install if missing: dotnet tool install -g pks-cli Add tools directory to PATH: # Linux/macOS export PATH=\"$PATH:$HOME/.dotnet/tools\" # Windows PowerShell $env:PATH += \";$env:USERPROFILE\\.dotnet\\tools\" .NET SDK Issues Problem: The command could not be loaded, possibly because: * You intended to execute a .NET application: The application 'pks' does not exist. Solutions: Install .NET 8.0 SDK: # Check current version dotnet --version # Should show 8.0.x or later Download from Microsoft: Visit: https://dotnet.microsoft.com/download Install .NET 8.0 SDK for your platform Project Initialization Issues Directory Already Exists Problem: ❌ Error: Directory 'my-project' already exists Solutions: Use force flag: pks init my-project --force Choose different name: pks init my-project-v2 Remove existing directory: rm -rf my-project pks init my-project Template Not Found Problem: ❌ Error: Template 'custom' not found Solutions: List available templates: pks init --list-templates Use valid template: pks init my-project --template api Available templates: console, api, web, agent, library Agent Issues Agent Creation Failed Problem: ❌ Error: Failed to create agent 'MyBot' Solutions: Check agent name uniqueness: pks agent list Use different name: pks agent create --name MyBot2 --type developer Remove existing agent: pks agent remove MyBot pks agent create --name MyBot --type developer Agent Won't Start Problem: ❌ Error: Agent 'DevBot' failed to start Solutions: Check agent status: pks agent status DevBot View agent logs: pks agent logs DevBot Restart agent: pks agent stop DevBot pks agent start DevBot Deployment Issues Build Failures Problem: ❌ Error: Build failed with 1 error(s) Solutions: Check build output: dotnet build --verbosity detailed Clean and rebuild: dotnet clean dotnet restore dotnet build Check for missing dependencies: dotnet list package --outdated dotnet restore --force Port Already in Use Problem: ❌ Error: Port 5000 is already in use Solutions: Use different port: dotnet run --urls=\"http://localhost:5001\" Kill existing process: # Linux/macOS lsof -ti:5000 | xargs kill -9 # Windows netstat -ano | findstr :5000 taskkill /PID <PID> /F Configure in appsettings.json: { \"Urls\": \"http://localhost:5001\" } MCP Integration Issues MCP Server Won't Start Problem: ❌ Error: Failed to start MCP server on port 3000 Solutions: Check if port is available: netstat -an | grep 3000 Use different port: pks mcp start --port 4000 Kill existing process: # Find and kill process using port 3000 lsof -ti:3000 | xargs kill -9 AI Tools Can't Connect Problem: ❌ Error: Connection refused to MCP server Solutions: Verify server is running: curl http://localhost:3000/health Check firewall settings: # Allow port in firewall sudo ufw allow 3000 Use localhost binding: pks mcp start --host 0.0.0.0 --port 3000 Performance Issues Slow Command Execution Problem: Commands take a long time to execute Solutions: Disable animations: export PKS_DISABLE_ANIMATIONS=true pks status Use quiet mode: pks deploy --quiet Check system resources: # Monitor CPU and memory usage top htop High Memory Usage Problem: PKS CLI consumes too much memory Solutions: Restart agents: pks agent restart --all Limit concurrent agents: # In pks.config.json { \"agents\": { \"maxConcurrentAgents\": 2 } } Clear cache: dotnet nuget locals all --clear Configuration Issues Invalid Configuration Problem: ❌ Error: Invalid configuration file Solutions: Validate JSON syntax: # Use online JSON validator or python -m json.tool pks.config.json Reset to defaults: rm ~/.pks/config.json pks init --reset-config Use example configuration: { \"agents\": { \"autoSpawn\": true, \"defaultType\": \"developer\" }, \"ui\": { \"colorScheme\": \"cyan\", \"animations\": true } } Environment-Specific Issues Windows Issues PowerShell Execution Policy: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser Path Issues: $env:PATH += \";$env:USERPROFILE\\.dotnet\\tools\" [Environment]::SetEnvironmentVariable(\"Path\", $env:PATH, \"User\") macOS Issues Homebrew .NET Installation: brew update brew install --cask dotnet Permission Denied: sudo chown -R $(whoami) ~/.dotnet Linux Issues Missing Dependencies: # Ubuntu/Debian sudo apt update sudo apt install -y dotnet-sdk-8.0 # CentOS/RHEL sudo dnf install -y dotnet-sdk-8.0 AppArmor/SELinux: # Check if blocking execution sudo dmesg | grep -i denied sudo ausearch -m avc -ts recent Getting More Help If these solutions don't resolve your issue: 1. Enable Verbose Logging pks --verbose [command] export PKS_LOG_LEVEL=debug 2. Check System Information # System info uname -a dotnet --info pks --version # Environment variables env | grep PKS 3. Collect Diagnostics # Create diagnostics package pks diagnostics --output diagnostics.zip 4. Report the Issue Create a detailed bug report at: https://github.com/pksorensen/pks-cli/issues/new Include: Environment: OS, .NET version, PKS CLI version Command: Full command that failed Error Message: Complete error output Steps to Reproduce: Numbered steps Expected vs Actual: What should happen vs what happens Logs: Relevant log files or verbose output 5. Community Support GitHub Discussions: https://github.com/pksorensen/pks-cli/discussions Stack Overflow: Tag your questions with pks-cli Prevention Tips Keep PKS CLI Updated dotnet tool update -g pks-cli Regular Maintenance # Clear caches dotnet nuget locals all --clear # Update global tools dotnet tool update -g pks-cli # Check for issues pks diagnostics --health-check Configuration Backup # Backup your configuration cp ~/.pks/config.json ~/.pks/config.json.backup Remember: Most issues are resolved quickly with a clean installation or configuration reset. Don't hesitate to ask for help in the community! \uD83D\uDE80"
  },
  "articles/tutorials/deployment-workflows.html": {
    "href": "articles/tutorials/deployment-workflows.html",
    "title": "Deployment Workflows\\n\\nComing soon - deployment tutorial. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Deployment Workflows\\n\\nComing soon - deployment tutorial."
  },
  "articles/tutorials/first-project.html": {
    "href": "articles/tutorials/first-project.html",
    "title": "Your First Project Tutorial | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Your First Project Tutorial This tutorial will walk you through creating your first agentic project with PKS CLI, from installation to deployment. By the end, you'll have a working intelligent API with AI agents helping your development workflow. What You'll Build We'll create a Smart Todo API that features: ✨ Modern .NET 8 REST API \uD83E\uDD16 AI agents for development assistance \uD83D\uDD0C MCP integration for AI tool connectivity \uD83D\uDCDA Comprehensive documentation \uD83D\uDE80 Deployment-ready configuration Time Required: 15-20 minutes Prerequisites Before starting, ensure you have: .NET 8.0 SDK installed PKS CLI installed (dotnet tool install -g pks-cli) A code editor (VS Code recommended) Basic familiarity with .NET and APIs Step 1: Create Your Project Let's start by creating a new intelligent API project: # Create the project with agentic capabilities pks init smart-todo-api --template api --agentic --mcp --description \"An intelligent todo API with AI assistance\" What happens here: PKS CLI creates a new directory smart-todo-api Sets up a .NET 8 API project structure Configures agentic capabilities Adds MCP (Model Context Protocol) for AI integration Creates documentation and configuration files You should see output like: \uD83E\uDD16 PKS CLI - Professional Agentic Simplifier ✨ Initializing project 'smart-todo-api'... \uD83D\uDD27 Running DotNetProjectInitializer... ✓ Created .csproj file ✓ Generated Program.cs ✓ Added .gitignore \uD83E\uDD16 Running AgenticFeaturesInitializer... ✓ Configured agentic capabilities ✓ Created agent configuration \uD83D\uDD0C Running McpConfigurationInitializer... ✓ Created .mcp.json ✓ Generated MCP configuration \uD83D\uDCD6 Running ClaudeDocumentationInitializer... ✓ Created CLAUDE.md ✓ Added development guidance \uD83D\uDCDD Running ReadmeInitializer... ✓ Generated comprehensive README.md \uD83C\uDF89 Project initialized successfully! Step 2: Explore the Project Structure Navigate to your new project and explore what was generated: cd smart-todo-api ls -la You'll see a structure like: smart-todo-api/ ├── Controllers/ # API controllers ├── Models/ # Data models ├── Services/ # Business logic ├── Program.cs # Application startup ├── smart-todo-api.csproj # Project configuration ├── README.md # Project documentation ├── CLAUDE.md # AI development guidance ├── .mcp.json # MCP server configuration ├── .gitignore # Git ignore rules ├── appsettings.json # App configuration └── pks.config.json # PKS CLI configuration Key files to understand: Program.cs - Modern .NET startup with dependency injection CLAUDE.md - Guidance for AI-assisted development .mcp.json - Configuration for AI tool integration pks.config.json - PKS CLI settings Step 3: Build and Run Let's make sure everything works: # Restore dependencies and build dotnet build # Run the application dotnet run You should see: Building... info: Microsoft.Hosting.Lifetime[14] Now listening on: http://localhost:5000 info: Microsoft.Hosting.Lifetime[0] Application started. Press Ctrl+C to shut down. Open your browser to http://localhost:5000/swagger to see the Swagger UI with your API endpoints. Press Ctrl+C to stop the application. Step 4: Create Your First AI Agent Now let's add an AI agent to help with development: # Create a development agent pks agent create --name DevBot --type developer --description \"Helps with API development and testing\" Output: \uD83E\uDD16 Creating AI Agent... Agent Configuration: • Name: DevBot • Type: Developer • Specialization: API development and testing • Status: Ready ✅ Agent 'DevBot' created successfully! \uD83D\uDCA1 Next steps: - Start the agent: pks agent start DevBot - View agent status: pks agent status DevBot - List all agents: pks agent list Let's check our agent: # List all agents pks agent list # Check agent details pks agent status DevBot Step 5: Start the MCP Server The MCP (Model Context Protocol) server enables AI tools to interact with your project: # Start the MCP server (in a new terminal) pks mcp start --port 3000 This starts a server that exposes your project's tools and data to AI clients like Claude or GitHub Copilot. Keep this terminal open - the MCP server needs to run continuously for AI integration. Step 6: Implement Todo Functionality Let's add some real functionality to our API. Create a Todo model and controller: Create the Todo Model # Create Models/Todo.cs cat > Models/Todo.cs << 'EOF' namespace SmartTodoApi.Models { public class Todo { public int Id { get; set; } public string Title { get; set; } = string.Empty; public string Description { get; set; } = string.Empty; public bool IsCompleted { get; set; } public DateTime CreatedAt { get; set; } = DateTime.UtcNow; public DateTime? CompletedAt { get; set; } public Priority Priority { get; set; } = Priority.Medium; } public enum Priority { Low = 1, Medium = 2, High = 3, Critical = 4 } } EOF Create the Todo Controller # Create Controllers/TodosController.cs cat > Controllers/TodosController.cs << 'EOF' using Microsoft.AspNetCore.Mvc; using SmartTodoApi.Models; namespace SmartTodoApi.Controllers { [ApiController] [Route(\"api/[controller]\")] public class TodosController : ControllerBase { private static List<Todo> _todos = new List<Todo> { new Todo { Id = 1, Title = \"Learn PKS CLI\", Description = \"Master the agentic development workflow\", Priority = Priority.High }, new Todo { Id = 2, Title = \"Build Smart API\", Description = \"Create an intelligent todo API\", Priority = Priority.Medium } }; private static int _nextId = 3; [HttpGet] public ActionResult<IEnumerable<Todo>> GetTodos() { return Ok(_todos); } [HttpGet(\"{id}\")] public ActionResult<Todo> GetTodo(int id) { var todo = _todos.FirstOrDefault(t => t.Id == id); if (todo == null) return NotFound(); return Ok(todo); } [HttpPost] public ActionResult<Todo> CreateTodo(Todo todo) { todo.Id = _nextId++; todo.CreatedAt = DateTime.UtcNow; _todos.Add(todo); return CreatedAtAction(nameof(GetTodo), new { id = todo.Id }, todo); } [HttpPut(\"{id}\")] public IActionResult UpdateTodo(int id, Todo todo) { var existingTodo = _todos.FirstOrDefault(t => t.Id == id); if (existingTodo == null) return NotFound(); existingTodo.Title = todo.Title; existingTodo.Description = todo.Description; existingTodo.Priority = todo.Priority; return NoContent(); } [HttpPost(\"{id}/complete\")] public IActionResult CompleteTodo(int id) { var todo = _todos.FirstOrDefault(t => t.Id == id); if (todo == null) return NotFound(); todo.IsCompleted = true; todo.CompletedAt = DateTime.UtcNow; return NoContent(); } [HttpDelete(\"{id}\")] public IActionResult DeleteTodo(int id) { var todo = _todos.FirstOrDefault(t => t.Id == id); if (todo == null) return NotFound(); _todos.Remove(todo); return NoContent(); } } } EOF Step 7: Test Your API Let's build and test the updated API: # Build the project dotnet build # Run the application dotnet run Now test your API endpoints: Using Swagger UI Open http://localhost:5000/swagger Try the different endpoints: GET /api/todos - List all todos POST /api/todos - Create a new todo GET /api/todos/{id} - Get specific todo PUT /api/todos/{id} - Update a todo POST /api/todos/{id}/complete - Mark as complete DELETE /api/todos/{id} - Delete a todo Using curl # Get all todos curl http://localhost:5000/api/todos # Create a new todo curl -X POST http://localhost:5000/api/todos \\ -H \"Content-Type: application/json\" \\ -d '{\"title\":\"Test PKS CLI\",\"description\":\"Try out the new features\",\"priority\":3}' # Mark todo as complete curl -X POST http://localhost:5000/api/todos/1/complete Step 8: Deploy Your Application PKS CLI makes deployment intelligent and straightforward: # Stop the running application (Ctrl+C) # Deploy to development environment pks deploy --environment dev --watch This will: Build your application in Release mode Create deployment configurations Monitor the deployment process Provide real-time status updates Step 9: Monitor with Agents Let's use our AI agents to help monitor and improve the application: # Start our development agent pks agent start DevBot # Check system status with AI insights pks status --ai-insights --watch # Get deployment status pks deploy status --environment dev What You've Accomplished Congratulations! You've successfully: ✅ Created an agentic API project with PKS CLI ✅ Implemented todo functionality with a RESTful API ✅ Set up AI agents for development assistance ✅ Configured MCP integration for AI tool connectivity ✅ Deployed your application with intelligent monitoring ✅ Tested all endpoints with real data Next Steps Now that you have a working agentic project: 1. Enhance with More Agents # Create specialized agents pks agent create --name TestBot --type testing --description \"API testing specialist\" pks agent create --name DocsBot --type documentation --description \"Technical documentation expert\" 2. Add Database Integration # Initialize with database support pks init advanced-todo-api --template api --agentic --database postgres --auth jwt 3. Explore Advanced Features Working with Agents - Deep dive into agent capabilities MCP Integration - Connect with AI tools Deployment Workflows - Advanced deployment strategies 4. Join the Community GitHub: pksorensen/pks-cli Discussions: Share your experiences and ask questions Issues: Report bugs or suggest improvements Troubleshooting Common Issues Build Errors: # Clean and rebuild dotnet clean dotnet build Port Already in Use: # Use different port dotnet run --urls=\"http://localhost:5001\" Agent Not Starting: # Check agent status pks agent status DevBot # Restart agent pks agent stop DevBot pks agent start DevBot MCP Server Issues: # Check if port is available netstat -an | grep 3000 # Use different port pks mcp start --port 4000 Summary You've now experienced the power of agentic development with PKS CLI! This tutorial covered: Creating intelligent projects with AI integration Setting up development agents for assistance Building and deploying modern .NET APIs Using MCP for AI tool connectivity Monitoring and managing applications The combination of beautiful terminal UI, intelligent automation, and AI-powered development assistance makes PKS CLI a powerful tool for modern .NET developers. Ready to build something bigger? Try creating a full-stack application with web frontend, or dive into the advanced tutorials to learn more about agent coordination and complex deployment scenarios. Happy coding! \uD83D\uDE80"
  },
  "articles/tutorials/mcp-setup.html": {
    "href": "articles/tutorials/mcp-setup.html",
    "title": "MCP Setup\\n\\nComing soon - MCP setup tutorial. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "MCP Setup\\n\\nComing soon - MCP setup tutorial."
  },
  "articles/tutorials/working-with-agents.html": {
    "href": "articles/tutorials/working-with-agents.html",
    "title": "Working with Agents\\n\\nComing soon - agent tutorial. | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "Working with Agents\\n\\nComing soon - agent tutorial."
  },
  "index.html": {
    "href": "index.html",
    "title": "PKS CLI Documentation | PKS CLI - Professional Kubernetes Simplifier",
    "summary": "PKS CLI Documentation \uD83E\uDD16 Professional Agentic Simplifier - The Next-Generation CLI for .NET Developers Welcome to the comprehensive documentation for PKS CLI, the revolutionary agentic development tool that brings AI-powered assistance to your .NET development workflow. What is PKS CLI? PKS CLI is a next-generation command-line interface that combines beautiful terminal experiences with cutting-edge agentic capabilities. It's designed to streamline .NET development through intelligent automation, AI-powered agents, and modern deployment workflows. Key Features \uD83C\uDFA8 Beautiful Terminal UI Stunning ASCII art and professional aesthetics Rich interactive elements with progress indicators Color-coded output with intuitive schemes Modern terminal experience rivaling web applications \uD83E\uDD16 Agentic Intelligence AI development agents for specialized tasks Intelligent automation that learns from patterns Predictive assistance based on project context Code analysis and optimization insights \uD83D\uDE80 Powerful Commands Project Initialization - Smart templates with best practices Agent Management - Create and coordinate AI development agents Intelligent Deployment - AI-optimized deployment strategies System Monitoring - Real-time insights with anomaly detection ASCII Art Generation - Beautiful terminal graphics and animations MCP Integration - Model Context Protocol for AI tool connectivity Quick Start Get up and running with PKS CLI in minutes: Install PKS CLI dotnet tool install -g pks-cli Create your first project pks init my-project --template api --agentic Explore the CLI pks --help Documentation Sections \uD83D\uDCDA Getting Started Learn the basics and create your first agentic project ⚡ Installation Step-by-step installation guide for all platforms \uD83D\uDCD6 Command Reference Complete reference for all PKS CLI commands \uD83C\uDFAF Tutorials Hands-on guides for common workflows and scenarios \uD83C\uDFD7️ Architecture Deep dive into PKS CLI's design and architecture ⚙️ Advanced Topics Configuration, customization, and advanced features \uD83E\uDD1D Contributing How to contribute to PKS CLI development Community and Support GitHub Repository: pksorensen/pks-cli Issues: Report bugs and request features Discussions: Ask questions and share experiences License PKS CLI is open source software licensed under the MIT license. Ready to revolutionize your .NET development experience? Get started now!"
  }
}